



# 1.MQ介绍

## 1.MQ是什么？

先进先出的一个数据结构

应用场景主要包含以下3个方面

* 应用解耦（解耦）
* 流量削峰（削峰）
* 数据分发（异步）

## 2.MQ的优点和缺点

优点：解耦、削峰、异步

缺点：

* 系统可用性降低（外部依赖越多，稳定性越差）
* 系统复杂度提高（以前是同步远程调用，现在是MQ的异步调用）
* 一致性问题（部分系统消息处理成功，部分系统消息处理失败）

## 3.各种MQ产品的比较

常见的MQ产品包括Kafka、ActiveMQ、RabbitMQ、RocketMQ。

| 特性       | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                 | Kafka                                                        |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ |
| 开发语言   | java                                                         | erlang                                                       | java                     | scala                                                        |
| 单机吞吐量 | 万级                                                         | 万级                                                         | 10万级                   | 10万级                                                       |
| 时效率     | ms级                                                         | us级                                                         | ms级                     | ms级以内                                                     |
| 可用性     | 高（主从架构）                                               | 高（主从架构）                                               | 非常高（分布式架构）     | 非常高（分布式架构）                                         |
| 功能特性   | 成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好 | 基于erlang开发，所以并发能力很强，性能及其好，延时很低；管理界面较丰富 | MQ功能毕竟完善，扩展性佳 | 只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。 |

# 2.RocketMQ快速入门



# 3.RocketMQ集群搭建

## 3.1 各角色介绍

* Producer： 消息的发送者；举例：发信者
* Consumer：消息接收者；举例：收信者
* Broker：暂存和传输消息；举例：邮局
* NameServer：管理Broker；举例：各个邮局的管理机构
* Topic：区别消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息
* Message Queue：相当于Topic的分区；用于并行发送和接收消息

## 3.2集群搭建方式

### 3.2.1 集群特点

* NameServer 是一个几乎无状态节点，可集群部署，节点之间无任何消息同步。
* Broke部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。
* Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。
* Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer即可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。

### 3.2.2 集群模式

#### 1) 单Master模式

这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用，可以用于本地测试。

#### 2) 多Master模式

一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：

* 优点：配置简单，单个Master宕机或者重启维护对应用无影响，在磁盘配置为RAID10时，即时机器宕机不可恢复的情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；
* 缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。

#### 3) 多Master多Slave模式（异步）

每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：

* 优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；
* 缺点：Master宕机，磁盘损坏情况下回丢失少量消息。

#### 4) 多Master多Slave模式（同步）

每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：

* 优点：收据与服务都无单点故障，Master宕机情况下，消息无延迟、服务可用性与数据可用性都非常高；
* 缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。

## 3.3 双主双从集群搭建

### 3.3.1 总体架构

消息高可用 采用2m2s（同步双写）方式

![image-20211113164222081](C:\Users\69079\AppData\Roaming\Typora\typora-user-images\image-20211113164222081.png)

### 3.3.2 集群工作流程

1. 启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。
2. Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息（IP + 端口等）以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。
3. 收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以发送消息时自动创建Topic。
4. Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。
5. Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。

# 4.消息发送样例

* 导入MQ客户端依赖

```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.4.0</version>
</dependency>
```

* 消息发送者步骤分析

```tex
1.创建消息生产者producer，并制定生产者组名
2.指定Nameserver地址
3.启动producer
4.创建消息对象，指定主题Topic、Tag和消息体
5.发送消息
6.关闭生产者producer
```

* 消息消费者步骤分析

```tex
1.创建消费者Consumer，制定消费者组名
2.指定Nameserver地址
3.订阅主题Topic和Tag
4.设置回调函数、处理消息
5.启动消费者consumer
```

## 4.1基本样例

### 4.1.1 消息发送

#### 1) 发送同步消息

这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。

```java
public class SyncProducer {
  	public static void main(String[] args) throw Exception {
        DefaultMQProducer producer = new DefaultMQProducer("group1");
        
        producer.setNamesrvAddr("192.168.25.135:9876;192.168.25.138:9876");
        
        producer.start();
        
        for(int i = 0;i < 10;i++) {
            Message msg = new Message("base","tag1",("Hello World" + i).getBytes());
            
            SendResult result = producer.send(msg);
            SendStatus status = result.getSendStatus();
            String msgId = result.getMsgId();
            int queueId = result.getMessageQueue().getQueueId();
        }
        
        producer.shutdown();
    }  
}
```

#### 2) 发送异步消息

异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。

```java
public class AsyncProducer {
    public static void main(String[] args) throw Exception {
        DefaultMQProducer producer = new DefaultMQProducer("group1");
        
        producer.setNamesrvAddr("192.168.25.135:9876;192.168.25.138:9876");
        
        producer.start();
        
        for(int i = 0;i < 10;i++) {
            Message msg = new Message("base","tag2",("Hello World" + i).getBytes());
            
            producer.send(msg,new SendCallback() {
                public void onSuccess(SendResult sendResult) {
                    System.out.println("发送结果" + sendResult);
                }
                
                public void onException(Throwable e) {
                    System.out.println("发送异常" + e); 
                }
            });
        }
    }
}
```

#### 3) 单向发送消息

这种方式主要用在不特别关心发送结果的场景，例如日志发送。

```java
public class OneWayProducer {
    public static void main(String[] args) throw Exception {
        DefaultMQProducer producer = new DefaultMQProducer("group1");
        
        producer.setNamesrvAddr("192.168.25.135:9876;192.168.25.138:9876");
        
        producer.start();
        
        for(int i = 0;i < 10;i++) {
            Message msg = new Message("base","tag3",("Hello World" + i).getBytes());
            
            producer.sendOneway(msg);
        }
        
        producer.shutdown();
    }
}
```

### 4.1.2 消费消息

#### 1) 负载均衡模式

消费者采用负载均衡方式消费消息，多个消费者共同消费队列消息，每个消费者处理的消息不同

```java
public class Consumer {
    public static void main(String[] args) {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("group1");
        
        consumer.setNamesrvAddr("192.168.25.135:9876;192.168.25.138:9876");
        
        consumer.subscribe("base","tag1");
        
        //设置消费模式
        consumer.setMessageModel(MessageModel.CLUSTERING);
        
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
                for (MessageExt msg : msgs) {
                    System.out.println(new String(msg.getBody()));
                }
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        
        consumer.start();
    }
}
```

#### 2) 广播模式

消费者采用广播方式消费消息，每个消费者消费的消息都是相同的

```java
public class Consumer {
    public static void main(String[] args) {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("group1");
        
        consumer.setNamesrvAddr("192.168.25.135:9876;192.168.25.138:9876");
        
        consumer.subscribe("base","tag1");
        
        //设置消费模式
        consumer.setMessageModel(MessageModel.BROADCASTING);
        
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) {
                for (MessageExt msg : msgs) {
                    System.out.println(new String(msg.getBody()));
                }
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        
        consumer.start();
    }
}
```

## 4.2 顺序消息

消息有序指的是可以按照消息的发送顺序来消费（FIFO）。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。

顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue（分区队列）；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。

下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一队列。

### 4.2.1 顺序消息生产

```java
public class Producer {
    public static void main(String[] args) throw Exception {
        DefaultMQProducer producer = new DefaultMQProducer("group1");
        
        producer.setNamesrvAddr("192.168.25.135:9876;19 2.168.25.138:9876");
        
        producer.start();
        
        List<OrderStep> orderSteps = OrderStep.build();
        
        for (OrderStep order : orderSteps) {
            Message message = new Message("OrderTopic","tag",order.toString().getBytes());
            
            SendResult sendResult = producer.send(message,new MessageQueueSelector() {
                @Ovrride
                public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {				
                    long orderId = (long) arg;
                    long index = orderId % mqs.size();
                    return mqs.get((int) index);
                }
            },order.getOrderId());
            
            System.out.println("发送结果：" + sendResult);
		}
        
        producer.shutdown();
	}
}
```

### 4.2.2 顺序消息消费

```java
public class Consumer {
    public static void main(String[] args) throws MQClientException {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("group1");
        
        consumer.setNamesrvAddr("192.168.25.135:9876;192.168.25.138:9876");
        
        consumer.subscribe("OrderTopic","*");
        
        consumer.registerMessageListener(new MessageListenerOrderly() {
        	@Override
            public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs,ConsumeOrderlyContext context) {
                for(MessageExt msg : msgs) {
                    System.out.println("消费消息：" + new String(msg.getBody()));
                }
                
                return ConsumeOrderlyStatus.SUCCESS;
            }
        });
        
        consumer.start();
    }
}
```



