# Java面试突击系列（一）：消息队列的面试连环炮

## 消息队列的面试连环炮

### 前言

* 你用过消息队列么？
* 说说你们项目里是怎么用消息队列的？
  * 我们有一个订单系统，订单系统会每次下一个新订单的时候，就会发送一条消息到ActiveMQ里去，后台有一个库存系统，负责获取消息，然后更新库存。
* 为什么使用消息队列？
  * 你的订单系统不发送消息到MQ，而是直接调用库存系统的一个接口，然后直接调用成功了，库存也更新了，那就不需要使用消息队列了呀
  * 使用消息队列的主要作用是：异步、解耦、削峰
* 消息队列都有什么优缺点？
* Kafka、ActiveMQ、RibbitMQ、RocketMQ都有什么优缺点？
* 如何保证消息队列的高可用？
* 如何保证消息不被重复消费？如何保证消息消费时的幂等性？
* 如何保证消息的可靠性传输，要是消息丢失了怎么办？
* 如何保证消息的顺序性？
* 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？
* 如果让你写一个消息队列，该如何进行架构设计，说一下你的思路？

面试官问的问题不是发散的，而是从点、铺开，比如先聊一聊高并发的话题，就这个话题里面继续聊聊缓存、MQ等等东西。对于每个小话题，比如说MQ，就会从浅入深。

### 为什么使用消息队列？

#### 剖析

首先明白为什么系统中要使用到消息队列这种东西？

因为之前面试的大量候选人，说自己项目中使用了Redis，MQ，但是其实他们并不清楚为什么要用这个东西，说白了就是为了用而用，或者是别人设计的架构，从头到尾就没有思考过。

没有对自己的架构问过为什么的人，一定是平时没有思考的人，面试官对这类候选人印象通常不好。

#### 解答

其实就是问问你消息队列有哪些场景，然后你项目里面的具体是什么场景，说说你在这个场景里用什么消息队列是什么？

消息队列的场景使用场景很多，主要是三个：解耦、异步、削峰

#### 解耦

**不使用MQ时**

A系统发送数据到B、C、D系统，但没有使用消息队列时候的耦合场景

![image-20200418212721479](https://img-blog.csdnimg.cn/img_convert/1067240a991bbfd8774baf1c0384792f.png)

当后面系统不断增加，比如E，F系统的加入，以及D系统的移除

![image-20200418213021225](https://img-blog.csdnimg.cn/img_convert/4195fa3d32f770768d179cd0f7f8c42f.png)

因为A系统和其他各种系统耦合起来，那么需要处理的事情会多出许多

**使用MQ后**

系统A发送一条消息，到消息队列中，哪个系统需要获取到哪里，那么从MQ中消费数据，如果新系统E加入的话，那么只需要编写代码，然后也直接从MQ中消费即可，当系统D不需要这个数据时，那么只需要不对该消息进行消费即可。系统A不需要考虑给谁发送数据，也不需要维护这个代码，不需要考虑人家是否调用成功、失败、超时等等情况

![image-20200419205127214](https://img-blog.csdnimg.cn/img_convert/65ffbb4bf89b23ddfadd62b367ce5480.png)

总结：通过一个MQ，发布和订阅模型，Pub/Sub模型，系统A就和其他系统彻底解耦。

需要考虑一下负责的系统中，是否有类似的场景，就是一个系统或者一个模块，调用了多个系统，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要同步调用接口的，如果用MQ给它异步化解耦，也是可以的，这个时候可以考虑在自己的项目中，是不是可以运用这个MQ来进行系统的解耦。

#### 异步

**不用MQ的同步高延时请求场景**

下面的一个场景就是系统A，调用了其他三个系统的服务，我们发现用户在执行一个请求后，需要花费很长的时间

![image-20200419205855859](https://img-blog.csdnimg.cn/img_convert/3b6810f8d747b8ab4bb01b1fdc93a24e.png)

我们发现，用户执行一个接口，就需要花费350毫秒，假设我们将每个接口的耗时增加，可能会将近花费1秒，这个时候一般用户几乎不能接受，因为一般互联网类的企业，对用户的直接操作，一般要求是每个请求都必须在200ms以内完成，因为这个是对用户是无感知的

**使用MQ进行异步化**

![image-20200419213232855](https://img-blog.csdnimg.cn/img_convert/4d32b054692d4a8c4f05729b7eb164b7.png)

系统A只需要发送消息到MQ中就直接返回了，然后其他系统各自在MQ中进行消费。用户在执行系统A的时候，就会感觉非常快就得到响应了。

#### 削峰

**没有用MQ的削峰**

![image-20200419213609511](https://img-blog.csdnimg.cn/img_convert/a0b560a56e3b0f9c7981fa3b639a3dfc.png)

一般的MySQL，抗到QPS=2000的时候就可以达到了瓶颈，如果每秒请求达到了5000的话，可能直接就把MySQL打死了。如果MySQL被打死，然后整个系统就崩溃，然后系统就没法使用。

但是中午的高峰期过了之后，到下午的时候，就成了低峰期，可能也就一万用户同时在网站上操作，每秒的请求数量可能就50个请求，对整个系统几乎没有任何压力。

**使用MQ来进行削峰**

![image-20200419235201993](https://img-blog.csdnimg.cn/img_convert/65eeae778161ef0f0fe56b50c0f6f277.png)

削峰就是大量的请求过来，然后MQ将其消化掉了，然后通过其他系统从MQ中取消息，在逐步进行消费，保证系统的有序运行。一般高峰期不会持续太长，在一段时间后，就会被下游系统消化掉。

### 消息队列有什么优点和缺点？

优点上面已经说了：解耦、异步、削峰，缺点呢？显而易见的

* 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人家ABCD四个系统好好的，没啥问题，这个时候却加入了MQ进行，万一MQ挂了怎么办？MQ挂了整套系统也会崩溃。
* 系统复杂度提供：硬生生加了MQ进来，你这么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？
* 一致性问题：A系统处理完了直接返回成功了，人都以为你的请求成功了，但是问题是，要在BCD三个系统中，BD两个系统写库成功了，结果C系统写库失败了，这样就会存在数据不一致的问题。
* 所以说消息队列实际上是一种复杂的架构，你引入它有好多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最后发现系统复杂性提升了一个数量级，也就是复杂10倍，但是关键时刻，用还是得用。

![image-20200420070841754](https://img-blog.csdnimg.cn/img_convert/2a1bf86f92f97ef65e46690c32a3154a.png)

### 有什么区别，以及适用场景？

主流MQ包括：kafka、ActiveMQ、RabbitMQ、RocketMQ

常见的MQ其实就上面的四种

| 特性       | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                                                     | Kafka                                                        |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单机吞吐量 | 万级，吞吐量比RocketMQ和Kafka要低一个数量级                  | 万级，吞吐量比RocketMQ和Kafka要低一个数量级                  | 10万级，RocketMQ也是可以支撑高吞吐量的一种MQ                 | 10万级，这是Kafka最大的有点，就是吞吐量高。一般配置和数据类的系统进行实时数据计算、日志采集等场景 |
| 时效性     | ms级                                                         | 微秒级，这是RabbitMQ的一大特点，就是延迟最低                 | ms级                                                         | 延迟在ms级内                                                 |
| 可用性     | 基于主从架构实现高可用                                       | 高，基于主从架构时效高可用                                   | 非常高、分布式架构                                           | 非常高，Kafka是分布式的，一个数据多个副本，少数机器宕机后，不会丢失数据，不会导致不可用 |
| 消息可靠性 | 有较低的概率丢失数据                                         | 消息不丢失                                                   | 经过参数优化配置，可用做到0丢失                              | 经过参数优化配置可用做到0丢失                                |
| 核心特点   | MQ领域的功能及其完善                                         | 基于Erlang开发，所以并发能力强，性能及其好，延时很低         | MQ功能较为完善，还是分布式的，扩展性好                       | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是实时上的标准。 |
|            | 非常成熟，功能强大，在业内大量公司以及项目都有应用。但是偶尔消息丢失的概率，并且现在社区以及国内应用都越来越少，官方社区对ActiveMQ5.X维护越来越少，而且确实主要是基于解耦和异步来用的，较少在大规模吞吐场景中使用 | erlang语言开发的，性能及其好，延时很低。而且开源的版本，就提供的管理界面非常棒，在国内一些互联网公司近几年用RabbitMQ也是比较多一些，特别适用于中小型的公司，缺点显而易见，就是吞吐量会低一点，这是因为它做的实现机制比较中，因为使用erlang开发，目前没有多少公司使用其开发，所以针对源码界别的定制，非常困难，因此公司的掌控非常弱，只能依赖于开源社区的维护。 | 接口简单易用，毕竟在阿里大规模应用过，有阿里平台保障，日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是OK的，还可以支撑大规模的topic数量，支持复杂的MQ业务场景。 | 仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级别的延迟，极高的可用性以及可靠性，分布式可用任意扩展。同时Kafka最好是支撑较少的topic数量即可，保证其超高的吞吐量。 |

综上所述：

* 一般的业务要引入MQ，最早大家都死用ActiveMQ，但是现在大家用的不多了，没有经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还算了，不太推荐使用
* RabbitMQ后面被大量的中小型公司所使用，但是erlang语言阻碍了大量的Java工程师深入研究和掌握它，对公司而言，几乎处于不可控的状态，但是RabbitMQ目前开源稳定，活跃度也较高。
* RocketMQ是阿里开源的一套消息中间件，目前也已经经历了天猫双十一，同时底层使用Java进行开发

如果中小型企业技术实力一般，技术挑战不是很高，可以推荐，RabbitMQ。如果公司的基础研发能力很强，想精确到源码级别的掌握，那么推荐使用RocketMQ。同时如果项目是聚焦于大数据领域的实时计算，日志采集等场景，那么Kafka是业内标准。

### 如何保证消息队列的高可用

#### 剖析

这个问题用的很好，不会具体到某个MQ，而是问一个整体，然后通过你使用的MQ，来具体谈谈MQ的可用性的理解。

#### RabbitMQ高可用性

RabbitMQ是比较有代表性的，因为是基于主从做高可用的。

RabbitMQ三种模式：单机模式、普通集群模式、镜像集群模式

##### 单机模式

就是demo级别，一般就是本地启动后玩一玩，没有人生产环境中使用。

##### 普通集群模式

* 意思就是在多台机器上启动多个RabbitMQ实例，每台机器启动一个，但是创建的Queue，只会放在一个RabbitMQ实例上，但是每个实例都同步Queue元数据，在消费的时候，实际上是连接到另外一个实例上，那么这个实例会从Queue所在实例上拉取数据过来，这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。所以这导致你要么消费每次随机连接一个实例，然后拉取数据，要么固定连接那个Queue所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。
* 而且如果那个放Queue的实例宕机了，会导致接下来其他实例无法从那个实例拉取，如果你开启了消息持久化，让RabbitMQ落地存储消息的话，消息不一定会丢，得等到这个实例恢复了，然后才可以继续从这个Queue拉取数据。

![image-20200420091806944](https://img-blog.csdnimg.cn/img_convert/660b8f48bd8168a2b4a0a3299bf76c21.png)

这里没有什么所谓的高可用性可言，这个方案主要就是为了解决吞吐量，就是集群中的多个节点来服务于某个Queue的读写操作。

存在两个确定

* 可能会在RabbitMQ中存在大量的数据传输
* 可用性没有什么保障，如果Queue所在节点宕机，就会导致Queue的消息丢失

##### 集群镜像模式

这种模式，才是RabbitMQ的高可用模式，和普通的集群模式不一样的是，你创建的Queue无论元数据还是Queue里的消息都会存在于多个实例中，然后每次你写消息到Queue的时候，都会自动把消息推送到多个实例的Queue中进行消息同步。

这样的好处在于，你任何一个机器宕机了，别的机器都可以用。坏处在于，性能开销提升，消息同步所有的机器，导致网络带宽压力和消耗增加，第二就是没有什么扩展性科研，如果某个Queue负载很重，你加机器，新增的机器也包含了这个Queue的所有数据，并没有办法线性扩展你的Queue

那么如何开启集群镜像策略呢？就在RabbitMQ的管理控制台，新增一个策略，这个策略就是镜像集群模式下的策略，指定的时候，可以要求数据同步到所有的节点，也可以要求就同步到指定数量的节点，然后再次创建Queue的时候，应用这个策略，就会自动将数据同步到其他节点上去了。

![image-20200420102752707](https://img-blog.csdnimg.cn/img_convert/7813a4a02a3b250297787aa16bbee06f.png)

集群镜像模式下，任何一个节点宕机了都是没问题的，因为其他节点还包含了这个Queue的完整的数据，别的consumer可以到其他活着的节点上消费数据。

但是这个模式还存在问题：就是不是分布式的，如果这个Queue的数据量很大，大到这个机器上的容量无法容纳的时候，此时应该怎么办呢？

#### Kafka实现高可用

![image-20200420104251328](https://img-blog.csdnimg.cn/img_convert/6ff71fcb8803353af84bbf920abffd41.png)

Kafka一个最基本的架构认识：多个broker组件，每个broker是一个节点，你创建一个topic，这个topic可以划分成多个partition，每个partition可以存在于不同的broker上，每个partition就放一部分数据。

这就是天然的分布式消息队列，就是说一个topic的数据，是分散在多个机器上的，每个机器上就放一部分数据。

实际上RabbitMQ之类的，并不是分布式消息队列，他就是传统的消息队列，只不过提供了一些集群、HA的机制而已，因为无论怎么玩，RabbitMQ一个Queue的数据都放在一个节点里了，镜像集群下，也是每个节点都放这个Queue的完整数据。

Kafka0.8以前，是没有HA机制的，就是任何一个broker宕机了，那个broker上的partition就废了，没法读也没办法写，没有什么高可用可言，而在0.8版本后，提供了HA机制，就是replica副本机制，每个partition的数据都会同步到其他机器上，形成自己的多个replica副本，然后所有的replica就是follower，写的时候，leader会负责数据都同步到所有的follower上，读的时候就直接读取leader上的数据即可。只能读写leader？很简单，要是你能随意读写每个follower，那么就必须保证数据一致性的问题，系统复杂度太高，很容易出问题，Kafka会均匀的将一个partition的所有replica分布在不同的机器上，这样才能够提高容错性

每个副本不会存储节点的全部数据，而是数据可能分布在不同的机器上。

![image-20200420105712380](https://img-blog.csdnimg.cn/img_convert/eca9effa49101374494e7f7b7fa1f5b2.png)

同时多个副本中，会选取一个作为leader，其他的副本是作为follower，并且只有leader能对外提供读写，同时leader在写入数据后，它还会把全部的数据同步到follower中，保证数据的备份。

此时，高可用的架构就出来了，假设现在某个机器宕机了，比如其中一个leader宕机了，但是因为每个leader下还有多个follower，并且每个follower都进行了数据的备份，因此Kafka会自动感知leader已经宕机，同时将其他的follower给选举出来，作为新的leader，并向外提供服务支持。

### 如何保证消息的重复消费？

面试题：如何保证消息的重复消费？如何保证消息消费的幂等性？

#### 剖析

其实这是一个常见的问题，既然是消费消息，那肯定是要考虑会不会重复消费？能不能避免重复消费？或者重复消费了也别造成系统异常可以吗？关于消息重复消费的问题，其实本质上就是问你使用消息队列如何保证幂等性，这个是你架构中要考虑的问题。

首先是比尔RabbitMQ、RocketMQ、Kafka都会出现消息重复消费的问题，因为这个问题通常不是MQ自己保证的，而是保证消息的不丢失，我们首先从Kafka上来说：

Kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，代表它的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息offset提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我从上次消费到的offset来继续消费。

但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启，如果碰到着急的，直接kill杀死进程，然后重启，这就会导致consumer有些消息处理了没来得及提交offset，然后重启后，就会造成少数消息重复消费的问题。

重复消费不可怕，重要的是有没有考虑过重复消费之后，怎么保证幂等性？

例如：有个系统，消费一条数据往数据库插入一条，要是消息重复消费了两次，那么就插入两条数据了，这个数据也就出错了。

![image-20200420112217458](https://img-blog.csdnimg.cn/img_convert/3f48f5176347be2cfd1e05ef2e064cd8.png)

消费者如果在准备提交offset，但是还没有提交的时候，消费者进行被重启，那么此时已经消费国的数据的offset并没有提交，Kafka也就不知道你已经消费了，那么消费者再次上线进行消费的时候，会把已经消费的数据，重新在传递过来，就是消息重复消费的问题。

#### 幂等性是什么？

通俗点说：幂等性就是一个数据，或者一个请求，给你执行多次，得保证对应的数据不会改变，并且不能出错，这就是幂等性。

### 怎么保证消息队列消费的幂等性？

一条数据重复出现两次，但是数据库里只有一条数据，这就保证了系统的幂等性。

#### 解决思路

* 比如那个数据要写库，首先根据主键查一下，如果这个数据已经有了，那就别插入了，执行update即可
* 如果用的是redis，那就没问题了，因为每次都是set操作，天然的幂等性
* 如果不是上面的两个场景，那就做的稍微复杂一点，需要让生产者发送每条消息的时候，需要加一个全局唯一的id，类似于订单id之后的东西，然后你这里消费到了之后，先根据这个id去redis中查找，之前消费过了么，如果没有消费过，那就进行处理，然后把这里id写入到redis中，如果消费过了，那就别处理了，保证别重复消费相同的消息即可。
* 还有比如基于数据库唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会重复，因为Kafka消费者还没来得及提交offset，重复数据拿到了以后，我们进行插入的时候，因为有了唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据。

![image-20200420113844967](https://img-blog.csdnimg.cn/img_convert/6fd641e98abd0c8bd1eccd6431b7daf2.png)

### 如何保证消息传输不丢失？

面试题：如何保证消息的可靠性传输（如何处理消息丢失的问题）？

#### 剖析

消息队列有三个重要原则：消息不能多，不能少

不能多，指的就是刚刚提到的重复消费和幂等性问题，不能少，指的是数据在传输过程中，不会丢失。

如果说使用MQ用来传递非常核心的消息，比如说计费，扣费的一些消息，比如设计和研发一套核心的广告平台，计算系统是一个很重要的业务，操作是很耗时的，所以说广告系统整体的架构里面，实际是将计费做成异步化的，然后中间就是加了一个MQ。例如在广告主投放了一个广告，约定的是每次用户点击一次就扣费一次，结果用户动不动就点击了一次，扣费的时候搞的消息丢了，公司就会不断的少几块钱。这样积少成多，这就是造成了公司的巨大损失。

#### 为什么会丢数据

丢数据，一般分为两种，要么是MQ自己弄丢了，要么是我们消费的时候弄丢了。我们可以从RabbitMQ和Kafka分别来进行分析。

RabbitMQ一般来说都是承载公司的核心业务的，数据时绝对不能弄丢的。

![image-20200420120701475](https://img-blog.csdnimg.cn/img_convert/55f403bdfddf458c1ef3fd34e5604f1c.png)

#### 生产者弄丢了数据

生产者将数据发送到RabbitMQ的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。

此时选择用RabbitMQ提供的事务功能，就是生产者发送数据之前，开启RabbitMQ事务（channel.txSelect），然后发送消息，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，那么就可以提交事务，但是问题是，RabbitMQ事务机制一搞，基本上吞吐量会下来，因为太损耗性能。

![image-20200420121835297](https://img-blog.csdnimg.cn/img_convert/bdd19693c496e7a9cafb3b2b7e6caf2d.png)

所以一般来说，如果你要确保写RabbitMQ消息别丢，可以开启confirm模式，在生产者那里设置开启confirm模式之后，RabbitMQ会给你回传一个ack消息，告诉你这个消息OK了，如果RabbitMQ没能处理这个消息，会给你回调一个接口，告诉你这个消息接收失败， 你可以重试

```java
//开启事务
try {
    //发送消息
} catch (Exception e) {
    //重试发送消息
}
//提交
```

但是，因为事务机制，是同步的

针对于上述事务所造成性能下降的问题，下面的方法是开启confirm模式

* 首先把channel设置成confirm模式
* 然后发送一个消息
* 发送完消息之后，就不用管了
* RabbitMQ如果接受到这个消息的话，就会回调你生产者本地的一个接口，通知你说这条消息我们已经收到了
* RabbitMQ如果在接受消息的时候出错了，就会回调这个接口

一般生产者如果要保证消息不丢失，一般是用confirm机制，因为是异步的模式，在发送消息之后，不会阻塞，直接可以发送下一条消息，这样吞吐量会更高一些。

#### RabbitMQ丢失数据

这个就是RabbitMQ直接丢失数据，这个时候就必须开启RabbitMQ的持久化，就是消息写入之后，同时需要持久化到磁盘中，哪怕是RabbitMQ自己宕机了，也能够从磁盘中读取之前存储的消息，这样数据一般就不会丢失了，但是存在一个极端的情况，就是RabbitMQ还没持久化的时候，就已经宕机了，那么可能会造成少量的数据丢失，但是这个概念是比较小的。

设置持久化的两个步骤，第一个是创建Queue的时候，将其持久化的，这样就保证了RabbitMQ持久化Queue的元数据，但是不会持久化Queue中的数据，第二个就是发送消息的时候，将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ将会将消息持久化到磁盘上，必须同时设置两个持久化才行，哪怕是RabbitMQ挂了，数据丢了，生产者收不到ACK，你也是可以自己重发的。

#### 消费者丢失数据

消费者丢失数据，主要是因为打开了AutoAck的机制，消费者会自动通知RabbitMQ，表明自己已经消费完这条数据了，但是如果你消费到了一条消息，还在处理中，还没有处理完，此时消费者就会自动AutoAck了，通知RabbitMQ说这条消息已经被消息了，此时不巧的是，消费者系统宕机了，这条消息就会丢失，因为RabbitMQ以为这条消息已经处理掉。

在消费者层面上，我们需要将AutoAck给关闭，然后每次自己确定已经处理完了一条消息后，你再发送ack给RabbitMQ，如果你还没处理完就宕机了，此时RabbitMQ还没收到你发的Ack消息，然后RabbitMQ就会把这条消息分配给其他的消费者去处理。

### 如何保证消息的顺序性

#### 场景

以前做过一个MySQL binlog同步系统，压力还是非常大的，日同步数据要达到上亿。常见一点的在于大数据项目中，就需要同步一个mysql库过来，如何对公司业务的系统做各种的复杂操作。

在MySQL里增删改一条数据，对应出来的增删改3条binlog，接着这三条binlog发送到MQ里面，到消费出来依次执行，这个时候起码得保证能够顺序执行，不然本来是：增加、修改、删除，然后被换成了：删除、修改、增加，不全错了呢。

本来这个数据同步过来，应该是最后删除的，结果因为顺序搞错了，最后这个数据被保留了下来，数据同步就出错

* RabbitMQ：一个Queue，多个consumer，这不明显乱了
* Kafka：一个topic，一个partition，一个consumer，内部多线程，就会乱套

在消息队列中，一个Queue中的数据，一次只会被一个消费者消费掉

![image-20200420150800480](https://img-blog.csdnimg.cn/img_convert/52546e58da7050cc9728aba5f2fb3e66.png)

但因为不同消费者的执行速度不一致，在存入数据库后，造成顺序不一致的问题

![image-20200420150935355](https://img-blog.csdnimg.cn/img_convert/bcec909311697bbb7ca4b0ef344b5aed.png)

#### RabbitMQ保证消息顺序性

RabbitMQ：拆分多个Queue，每个Queue一个consumer，就是多一些Queue而已，确实是麻烦，或者就是一个Queue，但是对于一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理。

下图为：一个consumer对应一个Queue，这样就保证了消息消费的顺序性。

![image-20200420151354856](https://img-blog.csdnimg.cn/img_convert/34d6f39fc57dad4a060de5718fd52cab.png)

#### Kafka保证消息顺序性

一个topic，一个partition，一个consumer，内部单线程消费，写N个内存，然后N个线程分别消费一个内存Queue即可。注意，Kafka中，写入一个partition中的数据，一定是有顺序的。

![image-20200420152349066](https://img-blog.csdnimg.cn/img_convert/5c264e76e68de85e836c3a35de4cda83.png)

但是在一个消费者的内部，假设有多个线程并发的进行数据的消费，那么这个消息又会乱掉

![image-20200420152542344](https://img-blog.csdnimg.cn/img_convert/d59762ffc2519c50289adca756abc280.png)

这个时候，我们需要引入内存队列，然后我们通过消息的key，然后我们通过hash算法，进行hash分发，将相同订单key的散列到我们的同一个内存队列中，然后每一个线程从这个Queue中拉数据，同时一个内存Queue也是有顺序的。

![image-20200420153622880](https://img-blog.csdnimg.cn/img_convert/1caa3585f8ed4c9df51830d0735ecb31.png)

### 百万消息积压在队列中如何处理？

如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有百万消息积压几小时，说说解决思路？

#### 剖析

MQ大幅度积压这件事挺常见的，一般不出，出了的话就是大型生产事故，例如：消费端每次消费之后要写MySQL，结果MySQL挂了，消费端就不动了，或者一直出错，导致消息消费速度极其慢。

#### 场景1：积压大量消息

几千万的消息积压在MQ中七八个小时，这也是一个真实遇到过的场景，确实是线上故障了，这个时候要不然就是修复consumer，让它恢复消费速度，然后傻傻的等待几个小时消费完毕，但是很显然这是一种比较不机智的做法。

假设1个消费者1秒消费1000条，1秒3个消费者能消费3000条，一分钟就是18万条，1000万条也需要花费1个小时才能够把消息处理掉，这个时候在设备允许的情况下，如何才能够快速处理积压的消息呢？

一般这个时候，只能够做紧急的扩容操作了，具体操作步骤和思路如下所示：

* 先修复consumer的问题，确保其恢复消费速度，然后将现有consumer都停止
* 临时建立好原先10倍或者20倍的Queue数量
* 然后写一个临时的分发数据的consumer程序，然后这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的Queue
* 接着临时征用10倍机器来部署consumer，每一批consumer消费一个临时Queue的数据
* 这种做法相当于临时将Queue资源和consumer资源扩大了10倍，以正常的10倍速度

![image-20200420160304030](https://img-blog.csdnimg.cn/img_convert/2bee995854aeb0b3e889277d4c2d7556.png)

也就是让消费者把消费，重新写入MQ中，然后再用10倍的消费者来进行消费。

![image-20200420160319662](https://img-blog.csdnimg.cn/img_convert/d484e18ca45a70a5ebaa2cc437b6a0fa.png)

#### 场景2：大量消息积压，并且设置了过期时间

假设你用的是RabbitMQ，RabbitMQ是可以设置过期时间的，就是TTL，如果消息在Queue中积压超过一定的时间，就会被RabbitMQ给清理掉，这个数据就没了。这个时候就不是数据被大量积压的问题，而是大量数据被直接搞丢了。

这种情况下，就不是说要增加consumer消费积压的消息，因为实际上没有啥积压的，而是丢了大量消息，我们可以采取的一个方案就是，批量重导，这个之前线上也有遇到类型的场景，就大量的消息积压的时候，然后就直接丢弃了数据，然后等高峰期过了之后，例如在晚上12点以后，就开始写程序，将丢失的那批数据，写一个临时程序，一点点查询出来，然后重新添加MQ里面，把白天丢的数据，全部补回来。

假设1万个订单积压在MQ里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单查询出来，然后手动发到MQ里面去再补一次。

#### 场景3：大量消息积压，导致MQ磁盘满了

如果走的方式是消息积压在MQ里，那么如果你很长时间都没有处理掉，此时导致MQ都快写满了，咋办？

这个时候，也是因为方案一执行的太慢了，只能写一个临时程序，接入数据来消费，然后消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到凌晨的时候，再把消息填入MQ中进行消费。

### 如何设计一个消息中间件架构？

如果让你写一个消息队列，该如何进行架构设计？说一下你的思路

这种问题，说白了，起码不求你看过那些技术的源码，但是你应该大概知道那些技术的基本原理，核心组成部分，基本架构构成，如何参照一些开源技术把一个系统设计出来的思路说一下就好了

#### 思路

* 首先MQ得支持可伸缩性，那就需要快速扩容，就可以增加吞吐量和容量，可以设计一个分布式的系统，参考Kafka的设计理念，broker -> topic -> partition，每个partition放一台机器，那就存一部分数据，如果现在资源不够了，可以给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多的数据，提高更高的吞吐量。
* 其次得考虑一下这个MQ的数据要不要落地磁盘？也就是需不需要保证消息持久化，因为这样可以保证数据的不丢失，那落地磁盘的时候怎么落？顺序写，这样没有磁盘随机读写的寻址开销，磁盘顺序堆的性能是很高的，这就是Kafka的思路。
* 其次需要考虑MQ的可用性？这个可以具体到我们上面提到的消息队列保证高可用，提出了多副本，leader和follower模式，当一个leader宕机的时候，马上选取一个follower作为新的leader对外提供服务。
* 需不需要支持数据0丢失？可以参考Kafka的零丢失方案

其实一个MQ肯定是很复杂的，问这个问题其实是一个开发性问题，主要想看看有没有聪架构的角度整体构思和设计的思维以及能力

### 消息队列相关问题总结

一般而言，如果一个面试官水平还不错，会沿着从浅入深挖一个点，然后按着这个思路一直问一下，除了这里的七大问题之后，甚至还能挑着你熟悉的一个MQ一直问到源码级别，还可能结合项目来仔细问，先讲讲具体的业务细节，然后将这些业务跟这些MQ的问题场景结合其阿里，看看你的每个细节时如何处理和实现的。



# Java面试突击系列（二）： 分布式搜索引擎的面试连环炮

## 分布式搜索引擎的面试连环炮

业内目前来说事实上的一个标准，就是分布式搜索引擎一般大家都是用  ElasticSearch，（原来的话使用的是 Solr），但是确实，这两年大家一般都用更加易用的 es。

ElasticSearch 和 Solr 底层都是基于 Lucene，而 Lucene 的底层原理是**倒排索引**。

### 倒排索引是什么

倒排索引适用于快速的全文检索，一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表

例如：

假设文档集合中包含五个文档，每个文档的内容如下所示，在图中最左端一栏是每个文档对应的编号，我们的任务就是对这个文档建立倒排索引

![image-20200420174829608](https://img-blog.csdnimg.cn/img_convert/5f39b561de759cf3a2e5ac638fbbfac9.png)

中文和英文等语言不通，单词之间没有明确分割符号，所以首先要用分词系统将文档自动切分成单词序列，这样每个文档就转换为由单词序列构成的数据流，为了系统后续处理方便，需要对每个不同的单词赋予唯一的单词编号，同时记录下哪些文档包含这个单词，在如此处理结束后，我们就可以得到最简单的倒排索引了

![image-20200420175115061](https://img-blog.csdnimg.cn/img_convert/08afb01b89354059e60b94e7e543e26c.png)

索引系统还可以记录除此之外的更多信息，下图是记录了单词出现的频率（TF），即这个单词在文档中出现的次数，之所以要记录这个信息，是因为词频信息在搜索结果排序时，计算查询和文档相似度是很重要的一个计算因子，所以将其记录在倒排列表中，以便后续排序时进行分值计算。

![image-20200420175534595](https://img-blog.csdnimg.cn/img_convert/dbdd58e7a4dae3719a92df301226a402.png)

倒排列表还可以记录单词在某个文档出现的位置信息

```tex
(1,<11>,1),(2,<7>,1),(3,<3,9>,2)
```

有了这个索引系统，搜索引擎可以很方便地响应用户的查询，比如用户输入查询词 “Facebook” ，搜索系统查找倒排索引，从中可以读出包含这个单词的文档，这些文档就是提供给用户的搜索结果，而利用单词频率信息，文档频率信息即可以对这些候选搜索结果进行排序，计算文档和查询的相似性，按照相似性得分由高到低排序输出，此即为搜索系统的部分内部流程。

### 中文分词器原理

#### 方法一

分词器的原理本质上是词典分词。在现有内存中初始化一个词典，然后在分词过程中挨个读取字符和字典中的字符相匹配，把文档中所有词语拆分出来的过程。

#### 方法二 字典树

Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

下面一个存放了【大学、大学生、学习、学习机、学生、生气、生活、活着】这个词典的 trie 树：

![image-20200630105344435](https://img-blog.csdnimg.cn/img_convert/ce3b5a22cd529894318402133446b096.png)

它可以看作是用每个词第 n 到第 n+1 层结点间路径哈希值的哈希树，每个结点是实际要存放的词。

现在用这个树来进行 “大学生活” 的匹配。依然从 “大” 字开始匹配，如下图所示：从根结点开始，沿最左边的路径匹配到了 大 字，沿着 “大” 结点可以匹配到 “大学”，继续匹配则可以匹配到 “大学生”，之后字典中再没有以 “大” 字开头的词，至此已经匹配到了【大学、大学生】，第一轮匹配结束

![image-20200630105421277](https://img-blog.csdnimg.cn/img_convert/0c00bdc11fc9bfa4fd3d49441e246674.png)

继续匹配 “学” 字开头的词，方法同上步，可匹配出【学生】

![image-20200630105436614](https://img-blog.csdnimg.cn/img_convert/ab2684121039e811967a32d7a069453a.png)

继续匹配 “生” 和 “活” 字开头的词，这样 “大学生活” 在词典中的词全部被查出来。

可以看到，以匹配 “大” 字开头的词为例，第一种匹配方式需要在词典中查询包含 “大”、“大学”、“大学生”、“大学生活”，共 4 次查询，而使用 trie 树查询时当找到 “大学生” 这个词之后就停止了该轮匹配，减少了匹配的次数，当要匹配的句子越长，这种性能优势就越明显。

#### 失败指针

再来看一下上面的匹配过程，在匹配 “大学生” 这个词之后，由于词典中不存在其他以 “大” 字开头的词，本轮结束，将继续匹配以 “学” 字开头的词，这时，需要再回到根结点继续匹配，如果这个时候 “大学生” 结点有个指针可以直指向 “学生” 节点，就可以减少一个查询，类似地，当匹配完 “学生” 之后如果 “学生” 结点有个指针可以指向 “生活” 结点，就又可以减少一次查询。这种当下一层结点无法匹配需要进行跳转的指针就是失败指针，创建好失败指针的树看起来如下图：

![image-20200630105709557](https://img-blog.csdnimg.cn/img_convert/af1b933a9b196fc9ac94783d84712ac1.png)

图上红色的线就是失败指针，指向的是当下层结点无法匹配时应该跳转到哪个结点继续进行匹配

失败指针的创建过程通常为：

* 创建好 trie 树
* BFS 每一个结点（不能使用 DFS，因为每一层结点的失败指针在创建时要确保上一层结点的失败指针全部创建完成）。
* 根结点的子结点的失败指针指向根结点。
* 其他结点查找其父结点的失败指针指向的结点的子结点是否有和该结点字相同的结点，如果有则失败指针指向该结点，如果没有则重复刚才的过程直至找到字相同的结点或根结点。

查询过程如下：

![image-20200630105955680](https://img-blog.csdnimg.cn/img_convert/699313add1c29eaf8a3e553522944db0.png)

### ES 的分布式架构原理能说一下么？

![01_elasticsearch分布式架构原理](https://img-blog.csdnimg.cn/img_convert/1f2072c515fa18f6fc1314a1fda0abe9.png)

ElasticSearch 设计的理念就是分布式搜索引擎，底层其实还是基于 Lucene 的。

核心思想就是在多台机器上启动多个 es 进程实例，组成了一个 es 集群。

es 中存储数据的基本单位是索引，比如说你现在要在 es 中存储一些订单数据，你就应该在 es 中创建一个索引，order_idx，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一张表。index -> type -> mapping -> document -> field。

index：mysql 里的一张表

type：没法跟 mysql 里去对比，一个 index 里可以有多个 type，每个 type 的字段都是差不多的，但是有一些略微的差别。

例如，有一个 index，是订单 index，里面专门是放订单数据的。你在 mysql 中建表，有些订单是实物商品的订单，比如一件衣服，一双鞋子；有些订单是虚拟商品的订单，比如游戏点卡、话费充值。就两种订单大部分字段是一样的，但是少部分字段可能有略微的一些差别。

所以就会在订单 index 里，建两个 type，一个实物商品订单 type，一个是虚拟商品订单 type，这两个 type 大部分字段是一样的，少部分字段是不一样的。

很多情况下，一个 index 里可能就一个 type，但是确实如果说是一个 index 里有多个 type 的情况，你可以认为 index 是一个类别的表，具体的每个 type 代表了具体的一个 mysql 中的表

每个 type 有一个 mapping，如果认为一个 type 是一个具体的一个表，index 代表了多个 type 的同属于的一个类型，mapping 就是这个 type 的表结构定义，你在 mysql 中创建一个表，肯定是要定义表结构的，里面有哪些字段，每个字段是什么类型。。。

mapping 就代表了这个 type 的表结构的定义，定义了这个 type 中每个字段名称，字段是什么类型的，然后还有这个字段的各种配置

实际上你往 index 里的一个 type 里面写的一条数据，叫做一条 document，一条 document 就代表了 mysql 中的某个表里的一行数据，每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值

接着你搞一个索引，这个索引可以拆分多个 shard，每个 shard 存储部分数据。

接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 primary shard，负责写入数据，但是还有几个 replice shard。primary shard 写入数据之后，会将数据同步到其他几个 replica shard 上去。

通过这个 replica 的方案，每个 shard 的数据都有多个备份，如果某个机器宕机了，没关系啊，还有别的数据副本在别的机器上呢。高可用了吧。

es 集群多个节点，会自动选举一个节点为 master 节点，这个 master 节点其实就是干一些管理的工作的，比如维护索引元数据，负责切换 primary shard 和 replice shard 身份等。

要是 master 节点宕机了，那么会重新选举一个节点为 master 节点。

如果是非 master 节点宕机了，那么会由 master 节点，让那个宕机节点上的 primary shard 的身份转移到其他机器上的 replica shard。你要是修复了那台宕机机器，重启了之后，master节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。

其实上述就是 ElasticSearch 作为一个分布式搜索引擎最基本的一个架构设计

### ES 查询和读取数据的工作原理是什么？

![01_es读写底层原理剖析](https://img-blog.csdnimg.cn/img_convert/9437a70da106f4bb55147f72cb169527.png)

1. es 写数据过程

   1. 客户端选择一个 node 发送请求过去，这个 node 就是 coordinating node（协调节点）
   2. coordinating node，对 document 进行路由，将请求转发给对应的 node（有 primary shard）
   3. 实际的 node 上的 primary shard 处理请求，然后将数据同步到 replica node
   4. coordinating node，如果发现 primary node 和所有 replica node 都搞定之后，就返回响应结果给客户端

2. es 读数据过程

   查询，GET 某一条数据，写入了某个 document，这个 document 会自动给你分配一个全局唯一的 id，doc id，同时也是根据 doc id 进行 hash 路由到对应的 primary shard 上面去。也可以手动指定 doc id，比如用订单 id，用户 id。

   你可以通过 doc id 来查询，会根据 doc id 进行 hash，判断出来当时把 doc id 分配到了哪个 shard 上面去，从那个 shard 去查询

   1. 客户端发送请求到任意一个 node，称为 coordinate node
   2. coordinate node 对 document 进行路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读者请求负载均衡
   3. 接收请求的 node 返回 document 给 coordinate node
   4. coordinate node 返回 document 给客户端

3. es 搜索数据过程

   es 最强大的是做全文检索，就是比如你有三条数据

   java 真好玩儿啊

   java 好难学啊

   j2ee 特别牛

   你根据 java 关键词来搜索，将包含 java 的 document 给搜索出来

   es 就会给你返回：java 真好玩儿啊，java 好难学啊

   1. 客户端发送请求到一个 coordinate node
   2. 协调节点将搜索请求转发到所有的 shard 对应的 primary shard 或 replica shard 也可以
   3. query phase：每个 shard 将自己的搜索结果（其实就是一些 doc id），返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果
   4. fetch phase：接着由协调节点，根据 doc id 去各个节点上拉取实际的 document 数据，最终返回给客户端

4. 搜索的底层原理，倒排索引，画图说明传统数据库和倒排索引的区别

5. 写数据底层原理

   1. 先写入 buffer，在 buffer 里的时候数据时搜索不到的；同时将数据写入 translog 日志文件

   2. 如果 buffer 快满了，或者到一定时间，就会将 buffer 数据 refresh 到一个新的 segment file 中，但是此时数据不是直接进入 segment file 的磁盘文件的，而是先进入 os cache 的，这个过程就是 refresh。

      每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 segment file，每秒钟会产生一个新的磁盘文件，segment file，这个 segment file 中就存储最近 1 秒内 buffer 中写入的数据

      但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，每秒创建换一个空的 segment file，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中

      操作系统里面，磁盘文件其实都有一个东西，叫作 os cache，操作系统缓存，就是说数据写入磁盘文件之前，会先进入 os cache，先进入操作系统级别的一个内存缓存中去

      只要 buffer 中的数据被 refresh 操作，刷入 os cache 中，就代表这个数据就可以被搜索到了

      为什么叫 es 是准实时的？NRT，near real-time，准实时。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能看到。

      可以通过 es 的 restful api 或者 java api，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 os cache 中，让数据立马就可以被搜索到。

      只要数据被输入 os cache 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去了

   3. 只要数据进入 os cache，此时就可以让这个 segment file 的数据对外提供搜索了

   4. 重复 1~3 步骤，新的数据不断进入 buffer 和 translog，不断将 buffer 数据写入一个又一个新的 segment file 中去，每次 refresh 完 buffer 清空，translog 保留。随着这个进程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 commit 操作。

      buffer 中的数据，倒是好，每隔 1 秒就被刷到 os cache 中去，然后这个 buffer 就被清空了。所以说这个 buffer 的数据始终是可以保持不会填满 es 进程的内存的。

      每次一条数据写入 buffer，同时会写入一条日志到 translog 日志文件中去，所以这个 translog 日志文件是不断变大的，当 translog 日志文件大到一定程度的时候，就会执行 commit 操作。

   5. commit 操作发送第一步，就是将 buffer 中的现有数据 refresh 到 os cache 中去，清空 buffer

   6. 将一个 commit point 写入文件，里面标识着这个 commit point 对应的所有 segment file

   7. 强行将 os cache 中目前所有的数据都 fsync 到磁盘文件中去

      translog 日志文件的作用是什么？就是在你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。

      所以需要将数据对应的操作写入一个专门的日志文件，translog 日志文件中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。

      commit 操作：1、写 commit point；2、将 os cache 数据 fsync 强刷到磁盘上去；3、清空 translog 日志文件

   8. 将现有的 translog 清空，然后再次重启启用一个 translog，此时 commit 操作完成。默认每隔 30 分钟会自动执行一次 commit，但是如果 translog 过大，也会触发 commit。整个 commit 的过程，叫作 flush 操作。我们可以手动执行 flush 操作就是将所有 os cache 数据刷到磁盘文件中去。

      不叫作 commit 操作，flush 操作。es 中的 flush 操作，就对应着 commit 的全过程。我们也可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去，记录一个 commit point，清空 translog 日志文件。

   9. translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每写操作必须是直接 fsync 到磁盘，但是性能会差很多。

      实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的，你的数据有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，有 5 秒的数据不在磁盘上，此时如果宕机，会导致 5 秒的数据丢失。

      如果你希望一定不能丢失数据的话，你可以设置一个参数，官方文档，百度一下。每次写入一条数据，都是写入 buffer，同时写入磁盘上的 translog ，但是这会导致写性能、写入吞吐量会下降一个数量级。本来一秒钟可以写 2000 条，现在你一秒钟只能写 200 条，都有可能。

   10. 如果是删除操作，commit 的时候会生产一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 被删除了

   11. 如果是更新操作，就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据

   12. buffer 每次 refresh 一次，就会产生一次 segment file，所以默认情况下是 1 秒钟一个 segment file，segment file 会越来越多，此时会定期执行 merge

   13. 每次 merge  的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉，然后将新的 segment file 写入磁盘，这里会写一个 commit point，标识所有新的 segment file，然后打开 segment file 供搜索使用，同时删除旧的 segment file。

       es 里的写流程，有 4 个底层的核心概念，refresh、flush、translog、merge

       当 segment file 多到一定程度的时候，es 就会自动触发 merge 操作，将多个 segment file 给 merge 成一个 segment file。

​				

### ES 在数据量很大的情况下（数十亿级别）如何提高查询性能



![01_filesystem cache对es性能的影响](https://img-blog.csdnimg.cn/img_convert/5df2bee445f89c263a73c1952133550b.png)





说实话，es 性能优化是没有什么可谈的，啥意思呢？就是不要期待着随手调一个参数，就可以万能的应对所有的性能慢的场景。也许有的场景是你换个参数，或者调整一下语法，就可以搞定，但是绝对不是所有场景都可以这样。

一块一块来分析吧

在这个海量数据的场景下，如何提升 es 搜索的性能，也是我们之前生产环境实践经验所得

* 性能优化的杀手锏——filesystem cache

os cache，操作系统的缓存

你往 es 里写的数据，实际上都写到磁盘文件里去了，磁盘文件里的数据操作系统会自动将里面的数据缓存到 os cache 里面去

es 的搜索引擎严重依赖于底层的 filesystem cache，你如果给 filesystem cache 更多的内存，尽量让内存可以容纳所有的 index segment file 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。

性能差距可以有大，我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1 秒，5 秒，10 秒。但是如果是走 filesystem cache，是走存内存的，那么一般来说性能比走磁盘要搞一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。

之前有个学员，一直在问我，说他的搜索性能，聚合性能，倒排索引，正排索引，磁盘文件，十几秒。。。

比如说，你，es 节点有 3 台机器，每台机器，看起来内存很多，64G，总内存，64 * 3 = 192G

每台机器个 es jvm heap 是 32G，那么剩下来留给 filesystem cache 的就是每台机器才 32G，总共集群里给 filesystem cache 的就是 32 * 3 = 96G 内存

我就问他，ok，那么就是你往 es 集群里写入的数据有多少数据量？

如果你此时，你整个，磁盘上索引数据文件，在 3 台机器上，一共占用了 1T 的磁盘容量，你的 es 数据量是 1T，每台机器的数据量是 300G

你觉得你的性能能好吗？filesystem cache 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差

当时他们的情况就是这样子，es 在测试，弄了 3 台机器，自己觉得还不错，64G 内存的物理机。自以为可以容纳 1T 的数据量。

归根结底，你要让 es 性能好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半

比如说，你一共要在 es 中存储 1T 的数据，那么你的多台机器留个 filesystem cache 的内存加起来综合，至少要到 512G，至少半数的情况下，搜索是走内存的，性能一般可以到几秒钟，2 秒，3 秒，5 秒

如果最佳情况下，我们自己的生产环境实践经验，所以说我们当时的策略，是仅仅在 es 中就存少量的数据，就是你要用来搜索的那些索引，内存留给 filesystem cache 的，就 100G，那么你就控制在 100G 以内，相当于是，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内

比如说你现在有一行数据

id name age ... 30个字段

但是你现在搜索，只需要根据 id name age 三个字段来搜索

如果你傻乎乎的往 es 里写入一行数据所有的字段，就会导致说 70% 的数据不用来搜索的，结果硬是占据了 es 机器上的 filesystem cache 的空间，单挑数据的数据量越大，就会导致 filesystem cache 能缓存的数据就越少

仅仅只是写入 es 中要用来检索的少数几个字段就可以了，比如说，就写入 es id name age 三个字段就可以了，然后你可以把其他的字段数据存在 mysql 里面，我们一般是建议用 es + hbase 的这么一个架构。

hbase 的特点是适用于海量数据的在线存储，就是对 hbase 可以写入海量数据，不要做复杂的搜索，就是很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了

从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 doc id，然后根据 doc id 到 hbase 里去查询每个 doc id 对应的完整的数据，给查出来，再返回给前端。

你最好是写入 es 的数据小于等于，或者是略大于 es 的 filesystem cache 的内存容量

然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 es，会每次查询都是 5~10 秒，现在可能性能就会很高，每次查询就 50ms。

ElasticSearch 减少数据量仅仅放要用于搜索的几个关键字段即可，尽量写入 es 的数据量跟 es 机器的 filesystem cache 是差不多的就可以了；其他不用来检索的数据放 hbase 里，或者 mysql。

* 数据预热

假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 filesystem cache 一倍，比如说你写入一台机器 60G 数据，结果 filesystem cache 就 30G，还是有 30G 数据留在了磁盘上。

举个例子，微博，你可以把一些大V，平时看的人很多的数据给提前你自己后台搞个系统，每隔一会，你自己的后台系统去搜索一下热数据，刷到 filesystem cache 里去，后面用户实际上来看这个热数据的时候，他们就直接从内存里搜索了，很快。

电商，你可以平时查看最多的一些商品，比如说 iphone 8，热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 filesystem cache 里去。

对于那些你觉得比较热的，经常会有人访问的数据，最好做一个专门的缓存预热子系统，就是对热数据，每隔一段时间，你就提前访问一下，让数据进入 filesystem cache 里去，这样期待下次别人访问的时候，一定性能会好一些。

* 冷热分离

关于 es 性能优化，数据拆分，我之前说将大量不搜索的字段，拆分到别的存储中去，这个就是类似于后面我最后要讲的 mysql 分库分表的垂直拆分。

es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少，频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引

你最好事将冷数据写入一个索引中，然后热数据写入另外一个索引中，这样可以确保热数据都在被预热之后，尽量都让它们留在 filesystem os cache 里，别让冷数据给冲刷掉。

* document 模型设计

有不少同学问我，mysql，有两张表

订单表：

| id   | order_code | total_price |
| ---- | ---------- | ----------- |
| 1    | 测试订单   | 5000        |

订单条目表：

| id   | order_id | goods_id | purchase_count | price |
| ---- | -------- | -------- | -------------- | ----- |
| 1    | 1        | 1        | 2              | 2000  |
| 2    | 1        | 2        | 5              | 200   |

我在 mysql 里，都是 `select * from order join order_item on order.id = order_item.order_id where order.id = 1`

| 1    | 测试订单 | 5000 | 1    | 1    | 1    | 2    | 2000 |
| ---- | -------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 测试订单 | 5000 | 2    | 1    | 2    | 5    | 200  |

在 es 里该怎么玩，es 里面的复杂的关联查询，复杂的查询语法，尽量别用，一旦用了性能一般都不太好

设计 es 里的数据模型

写入 es 的时候，搞成两个索引，order 索引，orderItem 索引

order 索引，里面就包含 id	order_code	total_price

orderItem 索引，里面写入进去的时候，就完成 join 操作，id	order_code	total_price	id	order_id	goods_id	purchase_count	price

写入 es 的 java 系统里，就完成关联，将关联好的数据直接写入 es 中，搜索的时候，就不需要利用 es 的搜索语法去完成 join 来搜索了

document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就是那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join，nested，parent_child 搜索都要尽量避免，性能都很差的。

* 分页性能优化

es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。

分布式的，你要查第 100 页的 10 条数据，你是不可能说从 5 个 shard，每个 shard 就查 2 条数据？最后到协调节点合并成 10 条数据？你必须得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等待操作，最后再次分页，拿到里面第 100 页的数据。

你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长。非常坑爹。所以用 es 做分页的时候，你会发现越到后面，就越是慢。

我们之前也是遇到过这个问题，用 es 作分页，前几页就十几毫秒，翻到 10 页之后，十几页的时候，基本上就要 5~10 秒才能查出来一页数据了

* 不允许深度分页/默认深度分页性能很惨

你系统不允许他翻那么深的页，pm，默认翻的越深，性能就越差

* 类似于 app 里的推荐商品不断下拉一页一页的

类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 scroll api，自己百度

scroll 会一次性给你生成所有数据的一个快照，然后每次翻页就是通过游标移动，获取下一页下一页这样子，性能会比上面说的那种分页性能也高很多很多

针对这个问题，你可以考虑用 scroll 来进行处理，scroll 的原理实际上是保留一个数据快照，然后在一定时间内，你如果不断滑动往后翻页的时候，类似于你现在在浏览微博，不断往下刷新翻页。那么就用 scroll 不断通过游标获取下一页数据，这个性能是很高的，比 es 实际翻页要好的多的多。

但是唯一的一点就是，这个适用于那种类似微博下拉翻页的，不能随意跳到任何一页的场景。同时这个 scroll 是要保留一段时间内的数据快照的，你需要确保用户不会持续不断翻页翻几个小时。

无论多少页，性能基本上都是毫秒级的

因为 scroll api 是只能一页一页往后翻的，是不能说，先进入第 10 页，然后去 120 页，回到 58 页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻

### ES 生产集群的部署架构是什么？每个索引的数据大概是多少？每个索引大概有多少分片？

这个问题，包括后面的 redis 什么的，谈到 es、redis、mysql 分库分表等等技术，面试必问！就是你生产环境咋部署的？说白了，这个问题没啥技术含量，就是看你有没有真正的生产环境里干过这事

有些同学可能没在生产环境中干过的，没实际去拿线上机器部署过 es 集群，也没实际玩过，也没往 es 集群里面导入过几千万甚至是几亿的数据量，可能你就不太清楚这里面的一些生产项目中的细节

如果你是自己就玩过 demo，没碰过真实的 es 集群，那你可能此时会懵，但是别懵。。。你一定要云淡风轻的回答出来这个问题，表示你确实干过这事

其实这个问题没啥，如果你确实干过 es，那你肯定了解你们生产 es 集群的实际情况，部署了机台机器？有多少个索引？每个索引有多大数据量？每个索引给了多少个分片？你肯定知道！

但是如果你确实没干过，也别虚，我给你说一个基本的版本，你到时候简单说一下就好了

* es 生产集群我们部署了 5 台机器，每台机器是 6 核 64G 的，集群总内存是 320G
* 我们 es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，15G。目前系统已经运行了几个月，现在集群里数据总量大概是 100G 左右。
* 目前线上有 5 个索引（这个结合你们自己业务来，看看自己有哪些数据可以放 es 的），每个索引的数据量大概是 20G，所以这个数据量之内，我们每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。

# Java面试突击系列（三）：分布式缓存

## 分布式缓存

在项目中缓存是如何使用的？缓存如果使用不当会造成什么后果？

### 为啥在项目里要用缓存？

用缓存，主要是两个用途：高性能、高并发

### 高性能

假设有这么个场景，有一个操作，一个请求过来，然后执行 N 条 SQL 语句，然后半天才查询出一个结果，耗时 600ms，但是这个结果可能接下来几个小时就不会变了，或者变了也可以不用立即反馈给用户，这个时候就可以使用缓存了。

我们可以把花费了 600ms 查询出来的数据，丢进缓存中，一个 key 对应一个 value，下次再有人来查询的时候，就不走 mysql 了，而是直接从缓存中读取，通过 key 直接查询出 value，耗时 2ms，性能提升 300 倍。这就是所谓的高性能。

就是把一些复杂操作耗时查询出来的结果，如果确定后面不怎么变化了，但是马上还有很多读请求，这个时候，就可以直接把结果存放在缓存中，后面直接读取缓存即可。

![img](https://img-blog.csdnimg.cn/img_convert/e6f7d7584d37f56c27aee01f560a3e25.png)

就第一次从数据库中获取，后面直接从缓存中获取即可，性能提升很高

### 高并发

MySQL 这么重的数据库，并不适合高并发，虽然可以使用，但是天然支持的就不好，因为 MySQL 的单机撑到 2000QPS 的时候，就容易报警了

![img](https://img-blog.csdnimg.cn/img_convert/46d231de377fea3aaa45e929a391acb8.png)

#### 为什么缓存可以支持高并发

首先因为缓存是走内存的，内存天然就可以支持高并发，但是数据库因为是存储在硬盘上的，因此不要超过 2000QPS

#### 场景

所以要是有一个系统，高峰期过来每秒的请求有 1W 个，要是 MySQL 单机的话，一定会宕机的，这个时候就只能用上缓存，把很多数据放在缓存中，这样请求过来了之后，就直接从缓存中获取数据，而不查询数据库。缓存的功能很简单，说白了就是一个 key-value 式数据库，单机支撑的并发量轻松超过一秒几万到十几万，单机的承载量是 MySQL 单机的几十倍。

#### 缓存带来的不良后果

场景的缓存问题有三个

* 缓存与数据库双写不一致的问题
* 缓存穿透
* 缓存雪崩
* 缓存并发竞争

# Java面试突击系列（四）：Redis面试常见问题

## Redis的面试连环炮

### 面试题

* Redis 和 Memcache 有什么区别？

* Redis 的线程模型是什么？
* Redis 的数据类型及应用场景？
* 为什么单线程的 Redis 比多线程的 Memcache 的效率要高？
* 为什么 Redis 是单线程但是还可以支撑高并发？
* Redis 如何通过读写分离来承受百万的 QPS？
* Redis 的持久化策略有哪些？AOF 和 RDB 各有什么优缺点？
* Redis 的过期策略以及 LRU 算法
* 如何保证 Redis 的高并发和高可用？
* Redis 的主从复制原理能介绍一下么？
* Redis 的哨兵原理能介绍一下么？
* Redis 主备切换的数据丢失问题：异步复制、集群脑裂
* Redis 哨兵的底层原理

### 剖析

Redis 最基本的一个内部原理和特点就是 NIO 异步的单线程工作模型。Memcache 是早些年个大互联网公司常用的缓存方案，但是现在近几年都是使用的 Redis，没有什么公司使用 Memcache 了。

注意：Redis 中单个 Value 的大小最大为 512MB，Redis 的 key 和 string 类型 value 限制均为 512MB

### Redis 和 Memcache 的区别

从 Redis 作者给出的几个比较

* Redis 拥有更多的数据结构
  * Redis 相比 Memcache 来说，拥有更多的数据结构和支持更丰富的数据操作，通常在 Memcache 里，你需要将数据拿到客户端来进行类似的修改，再 set 进去。这就大大增加了网络 IO 的次数和体积，在 Redis 中，这些复杂的操作通常和一般的 set/get 一样高效。所以，如果需要缓存能过支持更复杂的结构和操作，那么 Redis 是不错的选择
* Redis 内存利用率对比
  * 使用简单的 key-value 存储的话，Memcache 的内存利用率更高，而 Redis 采用 Hash 结构来做 key - value 存储，由于其组合式的压缩，其内存利用率会高于 Memcache
* 性能对比
  * 由于 Redis 只使用了单核，而 Memcache 可以使用多核，所以平均每核上 Redis 在存储小数据比 Memcache 性能更高，而在 100K 以上的数据中，Memcache 性能更高，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcache 还有略有逊色。
* 集群模式
  * Memcache 没有原生的集群模式，需要依赖客户端来实现往集群中分片写入数据，但是 Redis 目前是原生支持 cluster 模式的。

### Redis 都有哪些数据类型，及使用场景

* String

  * 最基本的类型，就和普通的 set 和 get，做简单的 key - value 存储

* Hash

  * 这个是类似于 Map 的一种结构，就是一半可以将结构化数据，比如对象（前提是这个对象没有嵌套其他对象）给缓存在 Redis 中，每次读写 Redis 缓存的时候，可以操作 hash 里面的某个

  ```java
  key = 150
  vlaue = {
      "id": 150,
      "name": "张三",
      "age": 20
  }
  ```

  * Hash 类的数据结构，主要是用来存放一些对象，把一些简单的对象给缓存起来，后续操作的时候，你可以直接仅仅修改这个对象中某个字段的值。