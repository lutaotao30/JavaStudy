### 二分查找

在升序数组 *nums* 中寻找目标值 *target*，对于特定下标 *i*，比较 *nums[i]* 和 *target* 的大小：

* 如果 *nums[i] = target* ，则下标 *i* 即为要寻找的下标；
* 如果 *nums[i] > target* ，则 *target* 只可能在下标 *i* 的左侧；
* 如果 *nums[i] < target*，则 *target* 只可能在下标 *i* 的右侧。

基于上述事实，可以在有序数组中使用二分查找寻找目标值。

二分查找的做法是，定义查找的范围 *[left,right]* ，初始查找范围是整个数组。每次取查找范围的中点 *mid* ，比较 *nums[mid]* 和 *target* 的大小，如果相等则 *mid* 即为要寻找的下标，如果不相等则根据 *nums[mid]* 和 *target*  的大小关系将查找范围缩小一半。

由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 *O(log n)* ，其中 *n* 是数组的长度。

二分查找的条件是查找范围不为空，即 *left <= right* 。如果 *target* 在数组中，二分查找可以保证找到 *target* ，返回 *target* 在数组中的下标。如果 *target* 不在数组中，则当 *left > right* 时结束查找，返回 -1。

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right) {
            int mid = (right - left) / 2 + left;
            if(nums[mid] == target) {
                return mid;
            } else if(nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }
}
```

  复杂度分析

* 时间复杂度： O(log n)，其中 n 是数组的长度。
* 空间复杂度：O(1)。

### 双指针

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

显然，如果数组 *nums* 中的所有数都是非负数，那么将每个数平方后，数组依然保持升序；如果数组 *nums* 中的所有数都是负数，那么将每个数平方后，数组会保持降序。

这样一来，如果我们能够找到数组 *nums* 中负数与非负数的分界数，那么就可以用类似「归并排序」

的方法了。具体地，我们设 *neg* 为数组 *nums* 中负数与非负数的分界线，也就是说，*nums[0]* 到 *nums[neg]* 均为负数，而  *nums[neg + 1]* 到 *nums[n - 1]* 均未非负数。当我们将数组 *nums* 中的数平方后，那么 *nums[0]* 到 *nums[neg]* 单调递减，*nums[neg + 1]* 到 *nums[n - 1]* 单调递增。

由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置 *neg* 和 *neg + 1* ，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans = new int[nums.length];
        int neg = -1;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] < 0) {
                neg = i;
            } else {
                break;
            }
        }

        int left = neg;
        int right = neg + 1;
        int index = 0;
        while(left >= 0 || right < nums.length) {
            if (left < 0) {
                ans[index] = nums[right] * nums[right];
                ++right;
            } else if (right == nums.length) {
                ans[index] = nums[left] * nums[left];
                --left;
            } else if (nums[left] * nums[left] < nums[right] * nums[right]) {
                ans[index] = nums[left] * nums[left];
                --left;
            } else {
                ans[index] = nums[right] * nums[right];
                ++right;
            }
            ++index;
        }

        return ans;
    }
}
```

同样地，我们可以使用两个指针分别指向位置 0 和 n - 1 ，每次比较两个指针对应的数，选择较大的那个**逆序**放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况，读者可以仔细思考其精髓所在。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans = new int[nums.length];
        int left = 0;
        int right = nums.length - 1;

        int index = nums.length - 1;
        while(left <= right) {
            if(nums[left] * nums[left] > nums[right] * nums[right]) {
                ans[index] = nums[left] * nums[left];
                left++;
            } else { 
                ans[index] = nums[right] * nums[right];
                right--;
            }
            index--;
        }
        return ans;
    }
}
```

### 滑动窗口

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**思路和算法**

我们先用一个例子考虑如何在较优的时间复杂度内通过本题。

我们不妨以实例一中的字符串 abcabcbb 为例，找出**每一个字符开始的，不包含重复字符的最长子串**，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：

* 以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；
* 以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；
* 以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；
* 以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb;
* 以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；
* 以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；
* 以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；
* 以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。

发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 *k* 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 *rk* 。那么当我们选择第 *k* + 1 个字符作为起始位置时，首先从 *k* + 1 到 *rk* ，直到右侧出现了重复字符为止。

这样一来，我们就可以使用「滑动窗口」来解决这个问题了：

* 我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 *rk* ；
* 在每一个的操作中，我们会将左指针向右移动一格，表示**我们开始枚举下一个字符作为起始位置**，然后我们可以不断地向右移动指针，但需要保证这两个指针对应的子串中没有重复字符。在移动结束后，这个子串就对应着**以左指针开始的，不包含重复字符的最长子串**。我们记录下这个子串的长度；
* 在枚举结束后，我们找到的最长的子串的长度即为答案。

**判断重复字符**

在上面的流程中，我们还需要使用一种数据结构来判断**是否有重复的字符**，常用的数据结构为哈希集合（即 `C++` 中的 `std::unordered_set` ，`Java` 中的 `HashSet` ， `Python` 中的 `set` ，`JavaScript` 中的 `Set` ）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们王哈希集合中添加一个字符。

```java
class Solution {
	public int lengthOfLongestSubstring(String s) {
        HashSet<Character> hs = new HashSet<>();
        int right = 0;
        int ans = 0;
        for (int i = 0; i < s.length(); i++) {
            if(i != 0) {
                hs.remove(s.charAt(i - 1));
            }

            while (right < s.length() && !hs.contains(s.charAt(right))) {
                hs.add(s.charAt(right));
                right++;
            }
            ans = Math.max(ans,right - i);
        }
        return ans;
    }
}
```

