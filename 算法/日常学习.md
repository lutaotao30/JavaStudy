### 二分查找

在升序数组 *nums* 中寻找目标值 *target*，对于特定下标 *i*，比较 *nums[i]* 和 *target* 的大小：

* 如果 *nums[i] = target* ，则下标 *i* 即为要寻找的下标；
* 如果 *nums[i] > target* ，则 *target* 只可能在下标 *i* 的左侧；
* 如果 *nums[i] < target*，则 *target* 只可能在下标 *i* 的右侧。

基于上述事实，可以在有序数组中使用二分查找寻找目标值。

二分查找的做法是，定义查找的范围 *[left,right]* ，初始查找范围是整个数组。每次取查找范围的中点 *mid* ，比较 *nums[mid]* 和 *target* 的大小，如果相等则 *mid* 即为要寻找的下标，如果不相等则根据 *nums[mid]* 和 *target*  的大小关系将查找范围缩小一半。

由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 *O(log n)* ，其中 *n* 是数组的长度。

二分查找的条件是查找范围不为空，即 *left <= right* 。如果 *target* 在数组中，二分查找可以保证找到 *target* ，返回 *target* 在数组中的下标。如果 *target* 不在数组中，则当 *left > right* 时结束查找，返回 -1。

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right) {
            int mid = (right - left) / 2 + left;
            if(nums[mid] == target) {
                return mid;
            } else if(nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }
}
```

  复杂度分析

* 时间复杂度： O(log n)，其中 n 是数组的长度。
* 空间复杂度：O(1)。



### 双指针

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

显然，如果数组 *nums* 中的所有数都是非负数，那么将每个数平方后，数组依然保持升序；如果数组 *nums* 中的所有数都是负数，那么将每个数平方后，数组会保持降序。

这样一来，如果我们能够找到数组 *nums* 中负数与非负数的分界数，那么就可以用类似「归并排序」

的方法了。具体地，我们设 *neg* 为数组 *nums* 中负数与非负数的分界线，也就是说，*nums[0]* 到 *nums[neg]* 均为负数，而  *nums[neg + 1]* 到 *nums[n - 1]* 均未非负数。当我们将数组 *nums* 中的数平方后，那么 *nums[0]* 到 *nums[neg]* 单调递减，*nums[neg + 1]* 到 *nums[n - 1]* 单调递增。

由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置 *neg* 和 *neg + 1* ，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans = new int[nums.length];
        int neg = -1;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] < 0) {
                neg = i;
            } else {
                break;
            }
        }

        int left = neg;
        int right = neg + 1;
        int index = 0;
        while(left >= 0 || right < nums.length) {
            if (left < 0) {
                ans[index] = nums[right] * nums[right];
                ++right;
            } else if (right == nums.length) {
                ans[index] = nums[left] * nums[left];
                --left;
            } else if (nums[left] * nums[left] < nums[right] * nums[right]) {
                ans[index] = nums[left] * nums[left];
                --left;
            } else {
                ans[index] = nums[right] * nums[right];
                ++right;
            }
            ++index;
        }

        return ans;
    }
}
```

同样地，我们可以使用两个指针分别指向位置 0 和 n - 1 ，每次比较两个指针对应的数，选择较大的那个**逆序**放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况，读者可以仔细思考其精髓所在。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans = new int[nums.length];
        int left = 0;
        int right = nums.length - 1;

        int index = nums.length - 1;
        while(left <= right) {
            if(nums[left] * nums[left] > nums[right] * nums[right]) {
                ans[index] = nums[left] * nums[left];
                left++;
            } else { 
                ans[index] = nums[right] * nums[right];
                right--;
            }
            index--;
        }
        return ans;
    }
}
```



### 滑动窗口

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**思路和算法**

我们先用一个例子考虑如何在较优的时间复杂度内通过本题。

我们不妨以实例一中的字符串 abcabcbb 为例，找出**每一个字符开始的，不包含重复字符的最长子串**，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：

* 以 (a)bcabcbb 开始的最长字符串为 (abc)abcbb；
* 以 a(b)cabcbb 开始的最长字符串为 a(bca)bcbb；
* 以 ab(c)abcbb 开始的最长字符串为 ab(cab)cbb；
* 以 abc(a)bcbb 开始的最长字符串为 abc(abc)bb;
* 以 abca(b)cbb 开始的最长字符串为 abca(bc)bb；
* 以 abcab(c)bb 开始的最长字符串为 abcab(cb)b；
* 以 abcabc(b)b 开始的最长字符串为 abcabc(b)b；
* 以 abcabcb(b) 开始的最长字符串为 abcabcb(b)。

发现了什么？如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 *k* 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 *rk* 。那么当我们选择第 *k* + 1 个字符作为起始位置时，首先从 *k* + 1 到 *rk* ，直到右侧出现了重复字符为止。

这样一来，我们就可以使用「滑动窗口」来解决这个问题了：

* 我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 *rk* ；
* 在每一个的操作中，我们会将左指针向右移动一格，表示**我们开始枚举下一个字符作为起始位置**，然后我们可以不断地向右移动指针，但需要保证这两个指针对应的子串中没有重复字符。在移动结束后，这个子串就对应着**以左指针开始的，不包含重复字符的最长子串**。我们记录下这个子串的长度；
* 在枚举结束后，我们找到的最长的子串的长度即为答案。

**判断重复字符**

在上面的流程中，我们还需要使用一种数据结构来判断**是否有重复的字符**，常用的数据结构为哈希集合（即 `C++` 中的 `std::unordered_set` ，`Java` 中的 `HashSet` ， `Python` 中的 `set` ，`JavaScript` 中的 `Set` ）。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们王哈希集合中添加一个字符。

```java
class Solution {
	public int lengthOfLongestSubstring(String s) {
        HashSet<Character> hs = new HashSet<>();
        int right = 0;
        int ans = 0;
        for (int i = 0; i < s.length(); i++) {
            if(i != 0) {
                hs.remove(s.charAt(i - 1));
            }

            while (right < s.length() && !hs.contains(s.charAt(right))) {
                hs.add(s.charAt(right));
                right++;
            }
            ans = Math.max(ans,right - i);
        }
        return ans;
    }
}
```



### 广度优先搜索/深度优先搜索

#### [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)

有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。

给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。

为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

##### 方法一：广度优先搜索

**思路及算法**

我们从给定的起点开始，进行广度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格加入队列，并将该方格的颜色更新，以防止重复入队。

注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。

**代码**

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int[] dx = new int[]{1,0,0,-1};
        int[] dy = new int[]{0,1,-1,0};

        int curColor = image[sr][sc];
        if(curColor == newColor) {
            return image;
        }

        int x = image.length, y = image[0].length;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{sr,sc});
        image[sr][sc] = newColor;
        while(!queue.isEmpty()) {
            int[] cell = queue.poll();
            int x1 = cell[0],y1 = cell[1];
            for(int i = 0;i < 4;i++) {
                int mx = x1 + dx[i],my = y1 + dy[i];
                if(mx >= 0 && mx < x && my >= 0 && my < y && image[mx][my] == curColor) {
                    queue.offer(new int[]{mx,my});
                    image[mx][my] = newColor;
                }
            }
        }

        return image;

    }
}
```

##### 方法二：深度优先搜索

**思路及算法**

我们从给定的起点开始，进行深度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。

注意：因为初始位置的颜色会被修改，所以我们需要保存初始位置的颜色，以便于之后的更新操作。

**代码**

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int curColor = image[sr][sc];
        if(curColor != newColor) {
            dfs(image,sr,sc,curColor,newColor);
        }
        return image;
    }

    private void dfs(int[][] image,int x,int y,int color,int newColor) {
        int[] dx = {1,0,0,-1};
        int[] dy = {0,1,-1,0};

        if(image[x][y] == color) {
            image[x][y] = newColor;
            for (int i = 0; i < 4; i++) {
                int mx = x + dx[i],my = y + dy[i];
                if(mx >= 0 && mx < image.length && my >=0 && my < image[0].length) {
                    dfs(image,mx,my,color,newColor);
                }
            }
        }
    }
}
```



#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

给你一个大小为 `m x n` 的二进制矩阵 `grid` 。

岛屿 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 水平或者竖直的四个方向上 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

岛屿的面积是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 。

##### 方法一：深度优先搜索

**算法**

* 我们想知道网格中每个连通形状的面积，然后取最大值。
* 如果我们在一个土地上，以4个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。
* 为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为0。这样我们就不会多次访问同一土地。

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int ans = 0;
        for(int i = 0;i < grid.length;i++) {
            for(int j = 0;j < grid[0].length;j++) {
                int rans = dfs(grid,i,j);
                if(rans > ans) {
                    ans = rans;
                }
            }
        }
        return ans;
    }

    private int dfs(int[][] grid,int x,int y){
        if(x < 0 || y < 0 || x == grid.length || y == grid[0].length || grid[x][y] != 1) {
            return 0;
        }

        int[] dx = new int[]{1,0,0,-1};
        int[] dy = new int[]{0,1,-1,0};
        int ans = 1;
        grid[x][y] = 0;
        for(int i = 0;i < 4;i++){
            int mx = x + dx[i],my = y + dy[i];
            ans += dfs(grid,mx,my);
        }

        return ans;
    }
}
```

##### 方法二：深度优先搜索 + 栈

**算法**

我们可以用栈来实现深度优先搜索算法。这种方法本质与方法一相同，唯一的区别是：

* 方法一通过函数的调用来表示接下来想要遍历哪些土地，让下一层函数来访问这些土地。而方法二把接下来想要遍历的土地放在栈里，然后在取出这些土地的时候访问它们。
* 访问每一片土地时，我们将围绕它四个方向进行探索，找到还未访问的土地，放入到栈 `stack` 中；
* 另外，只要栈 `stack` 不为空，就说明我们还有土地待访问，那么就从栈中取出一个元素并访问。

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int dx[] = {1,0,0,-1};
        int dy[] = {0,1,-1,0};
        int ans = 0;

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    Deque<int[]> queue = new LinkedList<>();
                    queue.push(new int[]{i,j});
                    grid[i][j] = 0;
                    int rans = 1;
                    while (!queue.isEmpty()) {
                        int[] cell = queue.pop();
                        for (int k = 0; k < 4; k++) {
                            int mx = cell[0] + dx[k],my = cell[1] + dy[k];
                            if(mx >= 0 && mx < grid.length && my >= 0 && my < grid[0].length && grid[mx][my] == 1) {
                                queue.push(new int[]{mx,my});
                                grid[mx][my] = 0;
                                rans++;
                            }
                        }
                    }
                    ans = Math.max(ans,rans);
                }
            }
        }
        return ans;
    }
}
```

##### 方法三：广度优先搜索

**算法**

我们把方法二中的栈改为队列，每次从队首取出土地，并将接下来想要遍历的土地放在队尾，就实现了广度优先搜索算法。

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int dx[] = {1,0,0,-1};
        int dy[] = {0,1,-1,0};
        int ans = 0;

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1) {
                    Queue<int[]> queue = new LinkedList<>();
                    queue.offer(new int[]{i,j});
                    grid[i][j] = 0;
                    int rans = 1;
                    while (!queue.isEmpty()) {
                        int[] cell = queue.poll();
                        for (int k = 0; k < 4; k++) {
                            int mx = cell[0] + dx[k],my = cell[1] + dy[k];
                            if(mx >= 0 && mx < grid.length && my >= 0 && my < grid[0].length && grid[mx][my] == 1) {
                                queue.offer(new int[]{mx,my});
                                grid[mx][my] = 0;
                                rans++;
                            }
                        }
                    }
                    ans = Math.max(ans,rans);
                }
            }
        }
        return ans;
    }
}
```



### 动态规划

