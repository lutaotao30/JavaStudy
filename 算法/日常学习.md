### 二分查找

在升序数组 *nums* 中寻找目标值 *target*，对于特定下标 *i*，比较 *nums[i]* 和 *target* 的大小：

* 如果 *nums[i] = target* ，则下标 *i* 即为要寻找的下标；
* 如果 *nums[i] > target* ，则 *target* 只可能在下标 *i* 的左侧；
* 如果 *nums[i] < target*，则 *target* 只可能在下标 *i* 的右侧。

基于上述事实，可以在有序数组中使用二分查找寻找目标值。

二分查找的做法是，定义查找的范围 *[left,right]* ，初始查找范围是整个数组。每次取查找范围的中点 *mid* ，比较 *nums[mid]* 和 *target* 的大小，如果相等则 *mid* 即为要寻找的下标，如果不相等则根据 *nums[mid]* 和 *target*  的大小关系将查找范围缩小一半。

由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 *O(log n)* ，其中 *n* 是数组的长度。

二分查找的条件是查找范围不为空，即 *left <= right* 。如果 *target* 在数组中，二分查找可以保证找到 *target* ，返回 *target* 在数组中的下标。如果 *target* 不在数组中，则当 *left > right* 时结束查找，返回 -1。

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right) {
            int mid = (right - left) / 2 + left;
            if(nums[mid] == target) {
                return mid;
            } else if(nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }
}
```

  复杂度分析

* 时间复杂度： O(log n)，其中 n 是数组的长度。
* 空间复杂度：O(1)。

### 双指针

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

显然，如果数组 *nums* 中的所有数都是非负数，那么将每个数平方后，数组依然保持升序；如果数组 *nums* 中的所有数都是负数，那么将每个数平方后，数组会保持降序。

这样一来，如果我们能够找到数组 *nums* 中负数与非负数的分界数，那么就可以用类似「归并排序」

的方法了。具体地，我们设 *neg* 为数组 *nums* 中负数与非负数的分界线，也就是说，*nums[0]* 到 *nums[neg]* 均为负数，而  *nums[neg + 1]* 到 *nums[n - 1]* 均未非负数。当我们将数组 *nums* 中的数平方后，那么 *nums[0]* 到 *nums[neg]* 单调递减，*nums[neg + 1]* 到 *nums[n - 1]* 单调递增。

由于我们得到了两个已经有序的子数组，因此就可以使用归并的方法进行排序了。具体地，使用两个指针分别指向位置 *neg* 和 *neg + 1* ，每次比较两个指针对应的数，选择较小的那个放入答案并移动指针。当某一指针移至边界时，将另一指针还未遍历到的数依次放入答案。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans = new int[nums.length];
        int neg = -1;
        for (int i = 0; i < nums.length; ++i) {
            if (nums[i] < 0) {
                neg = i;
            } else {
                break;
            }
        }

        int left = neg;
        int right = neg + 1;
        int index = 0;
        while(left >= 0 || right < nums.length) {
            if (left < 0) {
                ans[index] = nums[right] * nums[right];
                ++right;
            } else if (right == nums.length) {
                ans[index] = nums[left] * nums[left];
                --left;
            } else if (nums[left] * nums[left] < nums[right] * nums[right]) {
                ans[index] = nums[left] * nums[left];
                --left;
            } else {
                ans[index] = nums[right] * nums[right];
                ++right;
            }
            ++index;
        }

        return ans;
    }
}
```

同样地，我们可以使用两个指针分别指向位置 0 和 n - 1 ，每次比较两个指针对应的数，选择较大的那个**逆序**放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况，读者可以仔细思考其精髓所在。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans = new int[nums.length];
        int left = 0;
        int right = nums.length - 1;

        int index = nums.length - 1;
        while(left <= right) {
            if(nums[left] * nums[left] > nums[right] * nums[right]) {
                ans[index] = nums[left] * nums[left];
                left++;
            } else { 
                ans[index] = nums[right] * nums[right];
                right--;
            }
            index--;
        }
        return ans;
    }
}
```

